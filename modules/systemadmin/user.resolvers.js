import User from"./user.model.js";import bcrypt from"bcrypt";import Verification from"../verification/verification.model.js";import{generateAccessToken,generateRandomNo,getDevice,getIp,getLocation}from"../../globalFunction.js";import LoginReport from"../loginreport/loginreport.model.js";const userResolvers={Query:{users:async()=>{try{return await User.find({is_deleted:!1}).sort({createdAt:-1})}catch(e){return{status:400,type:"error",message:e.message}}},getUserById:async(e,s)=>{try{const e=await User.findById(s.id,{is_deleted:!1});return e||{status:400,type:"error",message:`User with ID ${s.id} not found`}}catch(e){return{status:400,type:"error",message:e.message}}}},Mutation:{login:async(e,s,t)=>{const a=await User.find({email_address:s.email_address,is_email_verify:!0});if(Array.isArray(a)&&0!==a.length){let e=a[0];var r=bcrypt.compareSync(s.password,e.password);let n=getIp(t.req),o=getDevice(t.req).userAgent,d=getLocation(n),c=generateRandomNo(10);if(r){var i=generateAccessToken(e.id);let s={user:e.id,ip:n,device:o,location:d,session_id:c,usertype:"User",status:"Success",timeStart:Date.now()};const t=new LoginReport(s);return await t.save(),{message:"You have successfully login",type:"success",token:i,status:200,user:e,session_id:c,expire:"20h"}}{let s={user:e.id,ip:n,device:o,location:d,usertype:"User",status:"Failed",session_id:c,timeStart:Date.now()};const t=new LoginReport(s);return await t.save(),{status:404,type:"error",message:"it looks like these are not your correct details"}}}return{status:200,type:"success",message:"User not found"}},verifyOTP:async(e,s)=>{const t=await Verification.find({token:s.otp,email_address:s.email_address,status:"Pending"});if(Array.isArray(t)&&0!==t.length){await Verification.findByIdAndDelete(t[0].id),await User.findOneAndUpdate({email_address:s.email_address},{is_email_verify:!0});return{status:200,type:"success",message:"Otp verified"}}return{status:404,type:"error",message:"Invalid code supplied"}},resendOTP:async(e,s)=>{const t=await Verification.find({email_address:s.email_address,status:"Pending"});if(Array.isArray(t)&&0!==t.length)return{status:404,type:"error",message:"email address not found"};let a=generateRandomNo(6),r={token:a,email_address:s.email_address,status:"Pending"};const i=new Verification(r);return await i.save(),{status:200,type:"success",message:"Otp sent successfully"+a}},deleteUser:async(e,s)=>{try{return await User.findByIdAndDelete(s.id)?{status:200,type:"success",message:"Agency successfully deleted"}:{status:400,type:"error",message:`User with ID ${s.id} not found`}}catch(e){return{status:400,type:"error",message:e.message}}},addUser:async(e,s)=>{try{const e=bcrypt.hashSync(s.data.password,10);s.data.status="active",s.data.password=e;const t=new User(s.data);await t.save();let a=generateRandomNo(6),r={token:a,email_address:s.data.email_address,status:"Pending"};const i=new Verification(r);return await i.save(),{status:200,type:"success",message:"User successfully added"+a}}catch(e){return{status:400,type:"error",message:e.message}}},updateUser:async(e,s)=>{try{return await User.findByIdAndUpdate(s.id,s.data,{new:!0,runValidators:!0})?{status:200,type:"success",message:"User successfully updated"}:{status:400,type:"error",message:`User with ID ${s.id} not found`}}catch(e){return{status:400,type:"error",message:e.message}}}}};export default userResolvers;