import Exam from"./exam.model.js";import{processBase64Upload,ALLOWED_DOCUMENT_TYPES}from"../../utils/fileUpload.js";import Group from"../group/group.model.js";import{requireAuth,authStudent}from"../../middleware/auth.js";function getAbsoluteUrl(e,t){const s=`${e.protocol||(e.secure?"https":"http")}://${e.get("host")}`;return new URL(t,s).href}const examResolvers={Query:{exams:async(e,t,s)=>{try{const e=requireAuth(s),t=e?.school[0].id;return await Exam.find({is_deleted:!1,school:t}).populate("group").populate("school").populate("questions").sort({createdAt:-1})}catch(e){return{status:400,type:"error",message:e.message}}},getExamById:async(e,t,s)=>{try{requireAuth(s);const e=await Exam.findById(t.id).populate("staff").populate("group").populate("questions");return e||{status:400,type:"error",message:`Exam with ID ${t.id} not found`}}catch(e){return{status:400,type:"error",message:e.message}}},getExamByKey:async(e,t,s)=>{try{const e=await authStudent(s),a=await Exam.findOne({examKey:e?.examKey,is_deleted:!1}).populate("school").populate("questions");return a||{status:400,type:"error",message:`Exam with key ${t.examKey} not found`}}catch(e){return{status:400,type:"error",message:e.message}}},getExamByExamKeyRegister:async(e,t)=>{try{const e=await Exam.findOne({examKey:t.examKey,is_deleted:!1,status:"Active"}).populate("school");if(!e)return{status:400,type:"error",message:`Exam with key ${t.examKey} not found`};return{id:e.id,name:e.name,examKey:e.examKey,examFormat:e.examFormat,status:e.status,access:e.access,school:e.school[0]?.id||"",settings:e?.settings}}catch(e){return{status:400,type:"error",message:e.message}}},getExamsByFormat:async(e,t)=>{try{return await Exam.find({examFormat:t.examFormat,is_deleted:!1}).populate("questions").sort({createdAt:-1})}catch(e){return{status:400,type:"error",message:e.message}}},getExamsByStatus:async(e,t)=>{try{return await Exam.find({status:t.status,is_deleted:!1}).populate("school").populate("staff").populate("group").populate("questions").sort({createdAt:-1})}catch(e){return{status:400,type:"error",message:e.message}}}},Mutation:{addExam:async(e,t,s)=>{try{const{data:e}=t,a=requireAuth(s),r=a?.school[0].id,o=a?.id;if(e.pdfFileBase64)try{const t=`/images/pdfs/${await processBase64Upload(e.pdfFileBase64,"pdfs",ALLOWED_DOCUMENT_TYPES,"exam")}`;e.pdfFile=getAbsoluteUrl(s?.req,t),delete e.pdfFileBase64}catch(e){return{status:400,type:"error",message:`Failed to upload PDF: ${e.message}`}}if(!e.group||Array.isArray(e.group)&&0===e.group.length){const t=await Group.findOne({is_default:!0,is_deleted:!1,school:r});if(t)e.group=t._id;else{const t=new Group({name:"All Exams",school:r,color:"#4CAF50",is_default:!0});await t.save(),e.group=t._id}}e.staff=[o],e.school=[r],e.examKey=Math.random().toString(36).substring(2,8).toUpperCase();const u=new Exam({...e});return await u.save(),{status:200,type:"success",message:"Exam created successfully",data:u}}catch(e){return{status:400,type:"error",message:`Failed to create exam: ${e.message}`}}},updateExam:async(e,t,s)=>{try{const{data:e}=t,a=requireAuth(s);a?.school[0].id;if(e.pdfFileBase64&&""!==e.pdfFileBase64)try{const t=`/images/pdfs/${await processBase64Upload(e.pdfFileBase64,"pdfs",ALLOWED_DOCUMENT_TYPES,"exam")}`;e.pdfFile=getAbsoluteUrl(s?.req,t),delete e.pdfFileBase64}catch(e){return{status:400,type:"error",message:`Failed to upload PDF: ${e.message}`}}const r=await Exam.findByIdAndUpdate(t.id,{$set:e},{new:!0,runValidators:!0});return r?{status:200,type:"success",message:"Exam updated successfully",data:r}:{status:400,type:"error",message:`Exam with ID ${t.id} not found`}}catch(e){return{status:400,type:"error",message:`Failed to update exam: ${e.message}`}}},updateExamAccess:async(e,t,s)=>{try{const e=requireAuth(s);e?.school[0].id;return await Exam.findByIdAndUpdate(t.id,{$set:{access:t.access}},{new:!0,runValidators:!0})?{status:200,type:"success",message:`Exam access updated to ${t.access} successfully`}:{status:400,type:"error",message:`Exam with ID ${t.id} not found`}}catch(e){return{status:400,type:"error",message:`Failed to update exam access: ${e.message}`}}},duplicateExam:async(e,t,s)=>{try{const e=requireAuth(s),a=(e?.school[0].id,await Exam.findById(t.id));if(!a)return{status:400,type:"error",message:`Exam with ID ${t.id} not found`};const r=Math.random().toString(36).substring(2,8).toUpperCase(),o=new Exam({...a.toObject(),_id:void 0,name:`${a.name} (Copy)`,examKey:r,status:"Active",createdAt:void 0,updatedAt:void 0});return await o.save(),{status:200,type:"success",message:"Exam duplicated successfully"}}catch(e){return{status:400,type:"error",message:`Failed to duplicate exam: ${e.message}`}}},deleteExam:async(e,t,s)=>{try{const e=requireAuth(s);e?.school[0].id;return await Exam.findByIdAndUpdate(t.id,{is_deleted:!0,date_deleted:new Date},{new:!0})?{status:200,type:"success",message:"Exam deleted successfully"}:{status:400,type:"error",message:`Exam with ID ${t.id} not found`}}catch(e){return{status:400,type:"error",message:`Failed to delete exam: ${e.message}`}}},deleteMultipleExams:async(e,t,s)=>{try{const e=requireAuth(s),a=(e?.school[0].id,await Exam.updateMany({_id:{$in:t.data}},{is_deleted:!0,date_deleted:new Date}));return 0===a.modifiedCount?{status:400,type:"error",message:"No exams found to delete"}:{status:200,type:"success",message:`${a.modifiedCount} exam(s) deleted successfully`}}catch(e){return{status:400,type:"error",message:`Failed to delete exams: ${e.message}`}}},updateExamStatus:async(e,t,s)=>{try{const e=requireAuth(s),a=(e?.school[0].id,await Exam.findByIdAndUpdate(t.id,{status:t.status},{new:!0}));return a?{status:200,type:"success",message:"Exam status updated successfully",data:a}:{status:400,type:"error",message:`Exam with ID ${t.id} not found`}}catch(e){return{status:400,type:"error",message:`Failed to update exam status: ${e.message}`}}},updateMultipleExamsStatus:async(e,t,s)=>{try{const e=requireAuth(s),a=(e?.school[0].id,await Exam.updateMany({_id:{$in:t.data}},{status:t.status}));return 0===a.modifiedCount?{status:400,type:"error",message:"No exams found to update"}:{status:200,type:"success",message:`${a.modifiedCount} exam(s) status updated successfully`}}catch(e){return{status:400,type:"error",message:`Failed to update exams status: ${e.message}`}}},moveExamsToGroup:async(e,t,s)=>{try{const e=requireAuth(s),a=e?.school?.[0]?.id,{examIds:r,targetGroupId:o}=t.data||{};if(!Array.isArray(r)||0===r.length)return{status:400,type:"error",message:"Please select at least one exam"};if(!o)return{status:400,type:"error",message:"Target group is required"};const u=await Group.findOne({_id:o,is_deleted:!1});if(!u)return{status:400,type:"error",message:"Target group not found"};const d=await Exam.find({_id:{$in:r},is_deleted:!1});if(!d.length)return{status:400,type:"error",message:"No valid exams found to move"};let i=0;for(const e of d){const t=Array.isArray(e.school)?e.school:[e.school];(!a||t.some(e=>String(e)===String(a)))&&(e.group=[u._id],await e.save(),i+=1)}return i?{status:200,type:"success",message:`${i} exam${1===i?"":"s"} moved successfully`}:{status:400,type:"error",message:"No exams were moved. Please verify your selection."}}catch(e){return{status:400,type:"error",message:`Failed to move exams: ${e.message}`}}},addQuestionsToExam:async(e,t,s)=>{try{const e=requireAuth(s),a=(e?.school[0].id,await Exam.findByIdAndUpdate(t.examId,{$addToSet:{questions:{$each:t.questionIds}}},{new:!0}).populate("questions"));return a?{status:200,type:"success",message:"Questions added to exam successfully",data:a}:{status:400,type:"error",message:`Exam with ID ${t.examId} not found`}}catch(e){return{status:400,type:"error",message:`Failed to add questions: ${e.message}`}}},removeQuestionsFromExam:async(e,t,s)=>{try{const e=requireAuth(s),a=(e?.school[0].id,await Exam.findByIdAndUpdate(t.examId,{$pull:{questions:{$in:t.questionIds}}},{new:!0}).populate("questions"));return a?{status:200,type:"success",message:"Questions removed from exam successfully",data:a}:{status:400,type:"error",message:`Exam with ID ${t.examId} not found`}}catch(e){return{status:400,type:"error",message:`Failed to remove questions: ${e.message}`}}}}};export default examResolvers;